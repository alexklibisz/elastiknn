# eks-cluster.tf - provisions all resources (autoscaling groups, etc.) required by EKS cluster.
# outputs.tf - defines the output configuration.

# -- VPC, subnets, availability zones --

variable "region" {
    default = "us-east-1"
    description = "AWS region"
}

provider "aws" {
    version = ">=2.28.1"
    region = "us-east-1"
}

# Access list of AWS availability zones in the provider's region.
data "aws_availability_zones" "available" {}

resource "random_string" "suffix" {
    length = 8
    special = false
}

locals {
    cluster_name = "elastiknn-${random_string.suffix.result}"
}

module "vpc" {
    source = "terraform-aws-modules/vpc/aws"
    version = "2.6.0"
    name = "elastiknn-vpc"
    cidr = "10.0.0.0/16"
    azs = data.aws_availability_zones.available.names
    private_subnets = ["10.0.1.0/24", "10.0.2.0/24", "10.0.3.0/24"]
    public_subnets = ["10.0.4.0/24", "10.0.5.0/24", "10.0.6.0/24"]

    # You can use a network address translation (NAT) gateway to enable instances in a private 
    # subnet to connect to the internet or other AWS services, but prevent the internet from 
    # initiating a connection with those instances. 
    enable_nat_gateway = true
    single_nat_gateway = true
    enable_dns_hostnames = true

    tags = {
        "kubernetes.io/cluster/${local.cluster_name}" = "shared"
    }

    public_subnet_tags = {
        "kubernetes.io/cluster/${local.cluster_name}" = "shared"
        "kubernetes.io/role/elb" = "1"
    }

    private_subnet_tags = {
        "kubernetes.io/cluster/${local.cluster_name}" = "shared"
        "kubernetes.io/role/internal-elb" = "1"
    }
}

# -- Security Groups --
# Original example uses one security group for each worker group.
# I combined them into one.
resource "aws_security_group" "worker_mgmt" {
    name_prefix = "worker_mgmt"
    vpc_id = module.vpc.vpc_id
    ingress {
        from_port = 22
        to_port = 22
        protocol = "tcp"
        cidr_blocks = [ "10.0.0.0/8" ]
    }
}

# -- EKS Cluster --

module "eks" {
    source = "terraform-aws-modules/eks/aws"
    cluster_name = local.cluster_name
    subnets = module.vpc.private_subnets
    tags = {
        Environment = "elastiknn"
        # Left out some tags from the original example.
    }
    vpc_id = module.vpc.vpc_id
    worker_groups = [
        {
            name = "default"
            instance_type = "t2.small"
            asg_desired_capacity = 1
            asg_max_capacity = 5
            additional_security_group_ids = [aws_security_group.worker_mgmt.id]
        },
        # TODO: figure out how to specify that a pod should run on one of these.
        # Maybe there is a way to apply labels to the nodes here?
        # {
        #     name = "high-performance"
        #     instance_type = "c5.4xlarge"
        #     asg_desired_capacity = 0
        #     asg_max_capacity = 20
        #     additional_security_group_ids = [aws_security_group.worker_mgmt.id]
        # }
    ]
}

data "aws_eks_cluster" "cluster" {
    name = module.eks.cluster_id
}

data "aws_eks_cluster_auth" "cluster" {
    name = module.eks.cluster_id
}

provider "kubernetes" {
    load_config_file = "false"
    host = data.aws_eks_cluster.cluster.endpoint
    token = data.aws_eks_cluster_auth.cluster.token
    cluster_ca_certificate = base64decode(data.aws_eks_cluster.cluster.certificate_authority.0.data)
}

# -- Outputs --
output "cluster_endpoint" {
  description = "Endpoint for EKS control plane."
  value       = module.eks.cluster_endpoint
}

output "cluster_security_group_id" {
  description = "Security group ids attached to the cluster control plane."
  value       = module.eks.cluster_security_group_id
}

output "kubectl_config" {
  description = "kubectl config as generated by the module."
  value       = module.eks.kubeconfig
}

# output "config_map_aws_auth" {
#   description = "A kubernetes configuration to authenticate to this EKS cluster."
#   value       = module.eks.config_map_aws_auth
# }

output "region" {
  description = "AWS region"
  value       = var.region
}

output "cluster_name" {
  description = "Kubernetes Cluster Name"
  value       = local.cluster_name
}
