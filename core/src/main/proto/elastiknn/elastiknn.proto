syntax = "proto3";

package klibisz.elastiknn;

option java_package = "com.klibisz.elastiknn";

import "scalapb/scalapb.proto";

enum Similarity {
    SIMILARITY_L1 = 0;
    SIMILARITY_L2 = 1;
    SIMILARITY_ANGULAR = 2;
    SIMILARITY_HAMMING = 3;
    SIMILARITY_JACCARD = 4;
}

// A vector of doubles, used for l1, l2, and angular similarity.
message FloatVector {
    repeated double values = 1 [(scalapb.field).collection_type="Array"];
}

// A sparse vector of booleans, represented by the true indices and total number of indices.
message SparseBoolVector {
    repeated uint32 true_indices = 1 [(scalapb.field).collection_type="Array"];
    uint32 total_indices = 2;
}

// Generic representation of a vector.
message ElastiKnnVector {
    // TODO: switch to sealed oneof. It simplifies the scala code a lot and doesn't really affect the other langs.
    oneof vector {
        FloatVector float_vector = 1;
        SparseBoolVector sparse_bool_vector = 2;
    }
}

message ProcessorOptions {

    message ExactComputedModelOptions {
        // Specify the similarity so vectors can be checked for compatibility when indexing.
        Similarity similarity = 1;
    }

    message JaccardIndexedModelOptions {
        string field_processed = 2;
    }

    message JaccardLshModelOptions {
        int64 seed = 1;
        string field_processed = 2;
        uint32 num_bands = 3;
        uint32 num_rows = 4;
    }

    // Path to the field where the raw vector is stored.
    string field_raw = 1;

    // Dimensionality of the raw floating-point vector.
    uint32 dimension = 2;

    // The model options which will determine how the vector gets preprocessed and stored.
    oneof model_options {
        ExactComputedModelOptions exact_computed = 3;
        JaccardIndexedModelOptions jaccard_indexed = 4;
        JaccardLshModelOptions jaccard_lsh = 5;
    }
}

// Body and options for the elastiknn_knn query.
message KNearestNeighborsQuery {

    message ExactComputedQueryOptions {
    }

    message JaccardIndexedQueryOptions {
    }

    message JaccardLshQueryOptions {
        // Number of approximate results which will have their exact scores computed.
        // This should be larger than the desired number of hits, but much smaller than the total size of the corpus.
        uint32 num_candidates = 1;
    }

    // Find the neighbors for a vector which has already been indexed.
    message IndexedQueryVector {
        string index = 1;
        string field = 2;
        string id = 3;
    }

    // Pipeline used to preprocess the vectors being queried.
    string pipeline_id = 1;

    // Options defining how the exact or LSH query should be executed.
    oneof query_options {
        ExactComputedQueryOptions exact_computed = 2;
        JaccardIndexedQueryOptions jaccard_indexed = 3;
        JaccardLshQueryOptions jaccard_lsh = 4;
    }

    // The query vector, either given explicitly or as a reference to an already-indexed vector.
    oneof query_vector {
        ElastiKnnVector given = 5;
        IndexedQueryVector indexed = 6;
    }

    // When true, maintain and use a cache of vectors in memory that avoids re-reading from the Lucene index.
    // Useful when querying against data which won't change. DO NOT use if your data changes between queries.
    bool use_cache = 7;
}
