syntax = "proto3";

package klibisz.elastiknn;

option java_package = "com.klibisz.elastiknn";

import "scalapb/scalapb.proto";

enum Similarity {
    SIMILARITY_L1 = 0;
    SIMILARITY_L2 = 1;
    SIMILARITY_ANGULAR = 2;
    SIMILARITY_HAMMING = 3;
    SIMILARITY_JACCARD = 4;
}

message ProcessorOptions {
    // Path to the field where the raw vector is stored.
    string field_raw = 1;

    // Dimensionality of the raw floating-point vector.
    uint32 dimension = 2;

    // The model options which will determine how the vector gets preprocessed and stored.
    // TODO: switch to sealed oneof. It simplifies the scala code a lot and doesn't really affect the other langs.
    oneof model_options {
        ExactModelOptions exact = 3;
        JaccardLshOptions jaccard = 4;
    }
}

message ExactModelOptions {
    // Specify the similarity so vectors can be checked for compatibility when indexing.
    Similarity similarity = 1;
}

message JaccardLshOptions {
    int64 seed = 1;
    string field_processed = 2;
    uint32 num_bands = 3;
    uint32 num_rows = 4;
}

// A vector of doubles, used for l1, l2, and angular similarity.
message FloatVector {
    repeated double values = 1 [(scalapb.field).collection_type="Array"];
}

// A sparse vector of booleans, represented by the true indices and total number of indices.
message SparseBoolVector {
    repeated uint32 true_indices = 1 [(scalapb.field).collection_type="Array"];
    uint32 total_indices = 2;
}

// Generic representation of a vector.
message ElastiKnnVector {
    // TODO: switch to sealed oneof. It simplifies the scala code a lot and doesn't really affect the other langs.
    oneof vector {
        FloatVector float_vector = 1;
        SparseBoolVector sparse_bool_vector = 2;
    }
}

// Body and options for the elastiknn_knn query.
message KNearestNeighborsQuery {

    // Options for running an exact (exhaustive) query. This is only recommended for small datasets.
    message ExactQueryOptions {
        string field_raw = 1;
        Similarity similarity = 2;
    }

    // Options for running locality-sensitive-hashing queries.
    message LshQueryOptions {
        // Pipeline used to index the original vectors.
        string pipeline_id = 1;
        // TODO: regular and multi-probe lsh options here.
    }

    // Find the neighbors for a vector which has already been indexed.
    message IndexedQueryVector {
        string index = 1;
        string field = 2;
        string id = 3;
    }

    // Options defining how the exact or LSH query should be executed.
    oneof query_options {
        ExactQueryOptions exact = 1;
        LshQueryOptions lsh = 2;
    }

    // The query vector, either given explicitly or as a reference to an already-indexed vector.
    oneof query_vector {
        ElastiKnnVector given = 3;
        IndexedQueryVector indexed = 4;
    }

    // When true, maintain and use a cache of vectors in memory that avoids re-reading from the Lucene index.
    // Useful when querying against data which won't change. DO NOT use if your data changes between queries.
    bool use_cache = 5;
}
